#
#
# +-------------+       +-------------+       +--------+       +----------+
# |             |       |             |       |        |       |          |
# | Particle.io |<----->| API Gateway |<----->| Lambda |<----->| DynamoDB |
# |             |       |             |       |        |       |          |
# +-------------+       +-------------+       +--------+       +----------+
#       ^                       ^
#       |                      |
#       |                      |
#       |                      |
#       v                      v
#   +--------+             +--------+
#   | Sensor |             | Client |
#   +--------+             +--------+
#
#
#
#
#















# Parameters:
  #
  # BucketName:
  #   Type: String
  #
  # DeviceID:
  #   Type: String
  #
  # ParticleToken:
  #   Type: String

Resources:


  # API Gateway
  #
  # This section describes the resources for the API Gateway
  # that exposes our REST API. 
  #
  # All interaction with the
  # system will be through this API. The app
  # will not directly connect to Particle.io and
  # nothing will directly connect to the database
  #
  # Rest API Methods:
  #    - POST /data
  #    - GET  /data
  #    - POST /config
  #    - GET  /config
  #    - POST /login
  #


  # An AWS API Gateway resource that we
  # then attach all our other URL resources
  # and HTTP methods to.
  RestAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Ref AWS::StackName

  # A deployment is a way of tracking verions
  # of the API that is deployed to a stage.
  # Must have "DependsOn" for each method.
  # RestDeployment:
  #   Type: AWS::ApiGateway::Deployment
  #   DependsOn:
  #     - MethodPostData
  #     - MethodPostConfig
  #     - MethodPostLogin
  #   Properties:
  #     RestApiId: !Ref RestAPI

  # A stage represents various versions of the
  # deployed API. We  only have a single
  # stage and don't really worry about this.
  # RestStage:
  #   Type: AWS::ApiGateway::Stage
  #   Properties:
  #     StageName: production
  #     RestApiId: !Ref RestAPI
  #     DeploymentId: !Ref RestDeployment

  # Allows us to limit usage of the
  # API by setting the number of times
  # per time period an API key works.
  # RestUsagePlan:
  #   Type: AWS::ApiGateway::UsagePlan
  #   Properties:
  #     ApiStages:
  #       - ApiId: !Ref RestAPI
  #         Stage: !Ref RestStage
  #     Quota: {Limit: 3000, Period: DAY}
  #     Throttle: {BurstLimit: 10, RateLimit: 2}
  #     UsagePlanName: !Ref AWS::StackName

  # This represents the URL at /data for publishing
  # and querying all data from the database
  # ResourceData:
  #   Type: AWS::ApiGateway::Resource
  #   Properties:
  #     ParentId: {Fn::GetAtt: [RestAPI, RootResourceId]}
  #     PathPart: data
  #     RestApiId: !Ref RestAPI

  # This represents the URL at /config for
  # configuring the sensor settings.
  ResourceConfig:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: {Fn::GetAtt: [RestAPI, RootResourceId]}
      PathPart: config
      RestApiId: !Ref RestAPI

  # This represents the URL at /login for checking
  # if we have a valid API key for a login step.
  ResourceLogin:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: {Fn::GetAtt: [RestAPI, RootResourceId]}
      PathPart: login
      RestApiId: !Ref RestAPI


  # An HTTP method for forwarding a data
  # HTTP request to the lambda function.
  # MethodPostData:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     ApiKeyRequired: true
  #     HttpMethod: POST
  #     AuthorizationType: NONE
  #     ResourceId: !Ref ResourceData
  #     RestApiId: !Ref RestAPI
  #     RequestModels: {application/json: ModelPostData}
  #     RequestValidatorId: !Ref RequestValidator
  #     Integration:
  #       Type: AWS_PROXY
  #       IntegrationHttpMethod: POST
  #       Uri: !Sub
  #         - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
  #         - LambdaArn: !GetAtt LambdaFunction.Arn
  #
  # MethodGetData:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     ApiKeyRequired: true
  #     HttpMethod: GET
  #     AuthorizationType: NONE
  #     ResourceId: !Ref ResourceData
  #     RestApiId: !Ref RestAPI
  #     RequestValidatorId: !Ref RequestValidator
  #     RequestParameters:
  #       method.request.querystring.id: true
  #       method.request.querystring.metric: true
  #       method.request.querystring.limit: true
  #       method.request.querystring.timestamp_eq: false
  #       method.request.querystring.timestamp_gt: false
  #       method.request.querystring.timestamp_lt: false
  #       method.request.querystring.timestamp_lte: false
  #       method.request.querystring.timestamp_gte: false
  #     Integration:
  #       Type: AWS_PROXY
  #       IntegrationHttpMethod: POST
  #       Uri: !Sub
  #         - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
  #         - LambdaArn: !GetAtt LambdaFunction.Arn

  # An HTTP method for forwarding a device data
  # HTTP request to the lambda function.
  # MethodDeviceData:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     ApiKeyRequired: true
  #     HttpMethod: ANY
  #     AuthorizationType: NONE
  #     ResourceId: !Ref ResourceDeviceData
  #     RestApiId: !Ref RestAPI
  #     Integration:
  #       Type: AWS_PROXY
  #       IntegrationHttpMethod: POST
  #       Uri: !Sub
  #         - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
  #         - LambdaArn: !GetAtt LambdaFunction.Arn

  # An HTTP POST method for setting device config
  # params. This will forward data to the Particle
  # cloud to transmit to the device.
  # MethodPostConfig:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     ApiKeyRequired: true
  #     HttpMethod: POST
  #     AuthorizationType: NONE
  #     ResourceId: !Ref ResourceConfig
  #     RestApiId: !Ref RestAPI
  #     RequestModels: {application/json: ModelPostConfig}
  #     RequestValidatorId: !Ref RequestValidator
  #     Integration:
  #       Type: HTTP
  #       IntegrationHttpMethod: POST
  #       Uri: https://api.particle.io/v1/devices/{deviceID}/config
  #       RequestTemplates:
  #         "application/json":
  #           Fn::Sub:
  #             - '
  #               #set($context.requestOverride.path.deviceID = "${deviceID}")
  #               #set($context.requestOverride.header.Authorization = "Bearer ${token}")
  #               {
  #                 "arg": "$util.escapeJavaScript($input.body)"
  #               }'
  #             - deviceID: !Ref DeviceID
  #               token: !Ref ParticleToken
      #   Type: MOCK
      #   RequestTemplates: {"application/json": '{"statusCode": 200}'}
      #   IntegrationResponses: [{StatusCode: 200}]
      # MethodResponses: [{StatusCode: 200}]

  # An HTTP POST method for to "log in" to the
  # API. In reality, this just always returns
  # success with no content. That allows us
  # to check that we have a valid API key
  # and acts as our "login" step.
  # MethodPostLogin:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     ApiKeyRequired: true
  #     HttpMethod: POST
  #     AuthorizationType: NONE
  #     ResourceId: !Ref ResourceLogin
  #     RestApiId: !Ref RestAPI
  #     Integration:
  #       Type: MOCK
  #       RequestTemplates: {"application/json": '{"statusCode": 200}'}
  #       IntegrationResponses: [{StatusCode: 200}]
  #     MethodResponses: [{StatusCode: 200}]
  #
  # RequestValidator:
  #   Type: AWS::ApiGateway::RequestValidator
  #   Properties:
  #     Name: PostConfig
  #     RestApiId: !Ref RestAPI
  #     ValidateRequestBody: true
  #     ValidateRequestParameters: true
  #
  # ModelPostConfig:
  #   Type: AWS::ApiGateway::Model
  #   Properties:
  #     ContentType: application/json
  #     Name: ModelPostConfig
  #     RestApiId: !Ref RestAPI
  #     Schema:
  #       $schema: 'http://json-schema.org/draft-04/schema#'
  #       title: something
  #       type: object
  #       properties:
  #         one: {type: integer}
  #         class: {type: string}


  # AWS Api Gateway uses this model to validate the request body of all incoming
  # HTTP POST requests to the /data endpoint. To use this model, the endpoint
  # is configured via: 
  #        RequestModels: {application/json: ModelPostData}
  # It uses JSON Schema to describe a request body that contains a JSON string
  # with the correct format. The format used is described in the README.md.
  # ModelPostData:
  #   Type: AWS::ApiGateway::Model
  #   Properties:
  #     ContentType: application/json  # only validate JSON data
  #     Name: ModelPostData
  #     RestApiId: !Ref RestAPI
  #     Schema:
  #       $schema: 'http://json-schema.org/draft-04/schema#'
  #       definitions: # "Definitions" allow us to pre-define types that can be referenced later
  #         metric:    # a "metric" corresponds to the {"timestamp": <int>, "value": <number>} item
  #           type: object
  #           properties:
  #               timestamp: {type: integer} # unix timestamps in whole numbered seconds
  #               value: {type: number}      # values can be floating point, so use "number"
  #           additionalProperties: false    # only "timestamp" & "value" are allowed
  #           required: [timestamp, value]   # both "timestamp" & "value" are always required
  #         metricList:  # a "metricList" corresponds to array of "metrics" as defined above
  #           type: array
  #           items:  {"$ref": "#/definitions/metric"}
  #       type: object
  #       properties:
  #         name: {type: string}  # corresponds to the ID of the sensor sending the data
  #         data:                 # contains all the sensor data with metric names as keys
  #           type: object        # use regex pattern so any string can be used as a metric name
  #           patternProperties: {^.*$: {"$ref": "#/definitions/metricList"}}
  #       additionalProperties: false  # only "id" & "data" are allowed
  #       required: [id, data]         # both "id" & "data" are always required






